# Executor

The executor will allow to run lua inside lua, or any other language.

A frontend will be used to get the Bytecode that the executor runs.

To most important thing is I want to be able to call a function generated by this like a normal lua function, and this is possible.

```lua
local context = {}
local fn = execute(context, {T = "F", A = {}, {T = "$"}}) -- defining a function that returns anything that is passed to it.
-- this is equivalent to `function(...) return ...`
-- now to call this function.

fn() -- this is it.
assert(fn(22) == 22) -- this will not assert, because the function will return 22.
local a, b = fn(2, 3) -- this will return the tuple that was pass in.
assert(a == 2)
assert(b == 3)
```

If you want to call a function is like this.

```lua
local context = {print = print}
local show_hello_world = execute(context, {T = "F", A = {}, {T = "C", P = {"print"}, {T = "I", "Hello World!"}} })
show_hello_world() -- stdout: `Hello World!`
```

By writing manual bytecode you can return a module.
There are to methods, you can return a function that returns a table or you can have a tuple that has a block and the generates a table. 

function module:
```lua
local context = {}
local module_as_function = execute(context, {T = "F", A = {}, {T = "T", {{T = "I", "a"}, {T = "I", 32}} } })
local module = module_as_function()
-- module == { a = 32 }
```

module like lua:
```lua
local context = {}
local module = execute(context, {T = 't', {
  T = "B", --[[This is the block, we do like `local foo = 32`]]
    {T = "D", "foo"} -- foo will not be inside context, if this is remove the foo can be accessed from context after execute.
    {T = "=", P = {{"foo"}}, {T = "I", 32}} -- this is like `foo = 32`
  },
  {T = "T", {{T = "I", "a"}, {T = "@", {"foo"}}} }
})
-- module == { a = 32 }
```

table:
```lua
local context = {}
local tb = execute(context, {T = "T", {{T = "I", "a"}, {T = "I", 32}} })
-- tb == { a = 32 }
```


- If/`?` has implicit return.

- functions/`F` has implicit return.

## Bytecode

Feels wrong to say that this is bytecode, but it's is.

The single invalid luau syntax is [1] and [2] inside tables, but I think this should be valid syntax, to say what is at a specific index.

```luau
type Path = {[number]:string} | number
-- If path is number is a tmp value that will be hidden from the context, is inside stack.tmp that cannot be accessed by nothing in that function call, is used to perform more complex stuff without creating a lot of locals or globals.

type Entry =
{
    T: "I", -- insert
    [number]: any -- only the first
}
-- When evaluated will return the V
|
{
    T: "T",
    [number]:{[1]: Entry, [2]: Entry},
}
-- This works with nested tables, and functions can be defined inside the table
-- When evaluated will return a table
|
{
    T: "D",
    [number]: string,
-- This is used to define a local variabile in the current stack, works like
}
|
{
    T: "=",
    P: {[number]: Path},
    L: {[number]: Entry?}?
    [number]: Entry, -- Values
-- The P is the paths, `{"self", "a"}` will reprezent `self.a` and `self["a"]`
-- If L is not nil at that P index, then will be used to index in the path, is for dynamic table access.
-- All evaluation results will be added into a array, after we have the results will use the path index and assign the value to that path, the remaining results will be discarded, this works exactly like `a,b = 1, 2` in lua.
}
|
{
    T: "@",
    L: {[number]: Entry?}?
    [number]: Path,
}
-- Will return the values in a tuple form, L is used to index dynamically in a table.
|
{
    T: "B"
    [number]: Entry,
-- This is a block used to evaluate multiples entries in order, the results will be discarded, but you can return
}
|
{
    T: "t",
    [number]: Entry,
-- This is used to create tuples all the results will be combine in a tuple
}
|
{
    T: "F",
    A: {[number]: string},
    [number]: Entry,
-- This will be evaluated to a function that can be called normally.
-- The A are the function arguments but all function are variadic, you can get the variadic par using the `{T = "$"}`, the variadic works like in normal lua.
}
|
{
    T: "C",
    P: Path,
    L: Entry?, -- used to access dynamically the function to call.
    [number]: Entry,
-- This is used to call a function.
-- The A is the arguments that will be evaluated and added to the function call.
-- The result can be a tuple, you need to run this inside a `{T = "="}` to get the results.
}
|
{
    T: "R",
    [number]: Entry
-- This is used to return from a function is like `return`.
}
|
{
    T: "b",
-- This will set the breaks for a loop
}
|
{
    T: "c",
-- This will set the continues for a loop
}
|
{
    T: "$",
-- This will evaluate to the variadic like: `...`
}
|
{
    T: "?",
    C: Entry,
    t: Entry?,
    f: Entry?,
-- This will evaluate C the C result is used as the if condition, the if is true will evaluate t or if is false will evaluate f and will return the result unlike lua
}
|
{
    T: "W",
    C: Entry,
    [number]: Entry,
-- This will work like a lua while every loop will check for the condition and if is true the will evaluate t if defined.
}
|
{
    T: "f",
    ["in"]: Entry,
    A: {[number]: string}, -- Arguments that will be removed from the current variadic, so this will work like a normal lua function.
    [number]: Entry,
-- This is a for in loop A are the locals names to store the values they can be a max of 9.
}
|
{
    T: "f",
    s: Entry, -- start
    e: Entry, -- end
    i: Entry, -- inc
    n: string, -- index name
    [number]: Entry,
-- This is a for like: `for index=s,e,i do end`, I is the local where to store the index
}
|
{
    T: "+",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] + [2]`, this is addition
}
|
{
    T: "-",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] - [2]`, this is subtract
}
|
{
    T: "*",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] * [2]`, this is multiply
}
|
{
    T: "/",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] / [2]`, this is divide
}
|
{
    T: "^",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] ^ [2]`, this is to power not xor because is lua
}
|
{
    T: "~",
    [1]: Entry,
    [2]: Entry?,
-- if [1] and [2] then This will evaluate to `[1] ~ [2]`, this is bit-xor
-- if [1] and not [2] then This will evanuate to `~[1]`, this is negate
}
|
{
    T: "..",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] .. [2]`, this is concat, used for strings
}
|
{
    T: "|",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] | [2]`, this is bit-or.
}
|
{
    T: "&",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] & [2]`, this is bit-and.
}
|
{
    T: "#",
    [number]: Entry,
-- This will evaluate to `#N`, this will return the length of the array as a tuple.
}
|
{
    T: ">>",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] >> [2]`, this is right shift.
}
|
{
    T: "<<",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] << [2]`, this is left shift.
}
|
{
    T: "%",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] % [2]`, this is modulo.
}
|
{
    T: ">",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] > [2]`, this is grater then.
}
|
{
    T: "<",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] < [2]`, this is less then.
}
|
{
    T: "==",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] == [2]`, this is eq.
}
|
{
    T: ">=",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] >= [2]`, this is grater or eq then.
}
|
{
    T: "<=",
    [1]: Entry,
    [2]: Entry,
-- This will evaluate to `[1] <= [2`, this is less or eq then.
}
```
